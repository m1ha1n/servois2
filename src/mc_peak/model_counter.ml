open Smt
open Spec
open Phi
open Util

(* 
   Implementation plan
   1. obtain the smt generated by choose
   2. translate it 
   3. run the unix command
   4. interpret result
*)

type mc_result = 
  | Sat of int
  | Unsat
  | Unknown

type smt_mc_formulae = string * string * string * string * string
type region_predicate = HPredConj of conjunction | HPredDisj of disjunction

(* Model counter interface, e.g. ABC MC *)
module type ModelCounterSig = sig
  val name : string
  val exec_paths : string list
  val bound_int : int
  val smt_fname : string
  val args : string array
  val parse_output : string list -> mc_result
end

(* Interface for counting regions of satisfying models where 
   conditions hold for ADT's commuting operations *)
module type CommuteConditionsCountSig = 
sig
  val smt_query_str: spec * method_spec * method_spec -> region_predicate -> smt_mc_formulae
  val count: string -> smt_mc_formulae -> mc_result 
  val count_pred: string -> string * string -> mc_result
end

module ABCModelCounter : ModelCounterSig = 
struct
  let name = "abc"

  let exec_paths = [
    "/usr/bin/abc"
  ]

  let smt_fname = "tmp.smt2"

  let bound_int = 4

  let args = [| ""; "-v"; "0"; "-bi"; string_of_int bound_int; "-i"; smt_fname |]

  let parse_sat = function 
    | [] -> Unknown
    | l::ls -> Sat (int_of_string l)

  let rec parse_output = function ls ->  
    match ls with
    | [] -> Unknown
    | l::ls -> 
      if (String.equal l "sat") then parse_sat ls 
      else if (String.equal l "unsat") then Unsat else parse_output ls 
   
end  

let run_mc_exec (prog : string) (args : string array) (smt_fname : string) =
  let chan_out, chan_in, chan_err =
    Unix.open_process_args_full prog args [||] in
  let pid = Unix.process_full_pid (chan_out, chan_in, chan_err) in
  Sys.set_signal Sys.sigalrm (
      Sys.Signal_handle (fun _ ->
          Unix.kill pid Sys.sigkill;
          raise Timeout)
      );
  flush stdout;
  let _ = waitpid_poll pid in
  set_timeout_handler ();
  let sout = read_all_in chan_out in
  let serr = read_all_in chan_err in
  close_out chan_in;
  sout, serr

let print_exec_result (out : string list) (err : string list) =
  pfvv "* * * OUT * * * \n%s\n* * * ERR * * * \n%s\n* * * * * *\n"
    (String.concat "\n" out) (String.concat "\n" err)

let run_model_counter (counter : (module ModelCounterSig)) : string list =
    let module MC = (val counter) in
    let exec = find_exec MC.name MC.exec_paths in
    let sout, serr = run_mc_exec exec MC.args MC.smt_fname in
    print_exec_result sout serr;
    sout

module CommuteConditionsCount: CommuteConditionsCountSig = 
struct
  let name_of_c_arg: ty binding -> string  = function
    | Var s, _ | VarPost s, _ | VarM (_, s), _ -> s
  
  let apply_method: ty bindlist -> string list -> exp -> exp = 
    fun args c_args body ->
      let substitution = List.combine (List.map name_of_binding args) c_args in 
      let substitute_var_for_arg v = 
        begin match (List.assoc_opt (string_of_var v) substitution) with
          | Some value -> Var value
          | _ -> raise @@ 
            UnreachableFailure (sp "Bound variable: [%s] not supplied!" (string_of_var v))
        end        
      in
      let apply : exp -> exp = 
        make_recursive (
          function 
          | EArg i -> raise @@ UnreachableFailure "EArg in mangling stage" 
          | EVar v -> EVar (substitute_var_for_arg v ) 
          | x -> x
        ) 
      in
      apply body
      
  let oper_pre_post: string -> ty bindlist -> method_spec -> string -> string -> exp * exp = 
    fun m_id state m pre_tag post_tag ->    
    let s_old = state in
    let s_new = make_new_bindings state in
    let pre_args = s_old @ m.args in
    let pre_c_args = 
      List.map (compose (Fun.flip String.cat pre_tag) name_of_c_arg) s_old 
      @ List.map (compose (Fun.flip String.cat m_id) name_of_c_arg) m.args
    in
    let pre' = apply_method pre_args pre_c_args m.pre in
    let post_args = s_old @ m.args @ s_new @ m.ret in 
    let post_c_args = 
      List.map (compose (Fun.flip String.cat pre_tag) name_of_c_arg) s_old 
      @ List.map (compose (String.cat (m_id ^ "_")) name_of_c_arg) m.args 
      @ List.map (compose (Fun.flip String.cat post_tag) name_of_c_arg) s_new 
      @ List.mapi (fun i _ -> sp "result_%d_" i ^ post_tag) m.ret
    in
    let post' = apply_method post_args post_c_args m.post in
    (pre', post')
  
  let smt_query_str (spec, m1, m2) h_pred  =
    (* 1. Preamble: types declaration *)
    let spec_preable = begin match spec.preamble with
      | Some s -> s
      | None -> ""
    end in
    
    (*2. Variable bindings *)
    let mk_var name ty = "(declare-fun " ^ name ^ " () " ^ Smt.string_of_ty ty ^ ")\n" in
    let m1args_binding = List.map (first string_of_var) m1.args in
    let m2args_binding = List.map (first string_of_var) m2.args in
    
    let (^=) s1 s2 = s1 := !s1 ^ s2 in
    let vars_ref = ref "" in
    (* Make a variable for each argument *)
    vars_ref ^= (uncurry mk_var 
                 |> Fun.flip List.map (m1args_binding @ m2args_binding) 
                 |> String.concat "");
    (* Work with partial transition functions; Filter out err variables from ADT's state *)
    let rollback_to_partiality: ty bindlist -> ty bindlist = 
      List.filter (fun tyb -> match (fst tyb) with
          | Var v -> not (String.starts_with ~prefix:"err" v)
          | _ -> true) in
    (* Make a variable for each state variable in each post state *)
    iter_prod (fun databinding e -> 
        vars_ref ^= mk_var (name_of_binding databinding ^ e) (snd databinding))
      (rollback_to_partiality spec.state) [""];
    (* Make results for m1, then m2, for each of the times we call them in the diamond. *)
    (* List.iteri (fun i ret ->
     *     vars_ref ^= mk_var (sp "result_%d_1" i) ret ^ mk_var (sp "result_%d_21" i) ret
     *     ) @@ List.map snd m1.ret;
     * List.iteri (fun i ret ->
     *     vars_ref ^= mk_var (sp "result_%d_2" i) ret ^ mk_var (sp "result_%d_12" i) ret
     *     ) @@ List.map snd m2.ret; *)

    (* 3. Translation of specs into one huge conjunction *)
    let oper =
      let list_of_oper_pre_post m_id state m pre_tag post_tag = 
        oper_pre_post m_id state m pre_tag post_tag 
        |> (fun (pre, post) -> [pre; post]) 
      in 
      let err_state_condition e0 e1 e12 e2 e21 = if Spec.has_err_state spec then
          [begin match !(Solve.mode) with
             | Solve.Bowtie -> Smt.ELop(Smt.Or, [
                 Smt.EUop(Smt.Not, EVar(Var ("err" ^ e12)));
                 Smt.EUop(Smt.Not, EVar(Var ("err" ^ e21)))])
             | Solve.LeftMover -> Smt.EUop(Smt.Not, EVar(Var ("err" ^ e21)))
             | Solve.RightMover -> Smt.EUop(Smt.Not, EVar(Var ("err" ^ e12)))
          end]
          else []
      in
      list_of_oper_pre_post "m1" spec.state m1 "" "1" 
      @ list_of_oper_pre_post "m2" spec.state m2 "1" "12"
      @ list_of_oper_pre_post "m2" spec.state m2 "" "2" 
      @ list_of_oper_pre_post "m1" spec.state m1 "2" "21"
      @ err_state_condition "" "1" "12" "2" "21"
    in
    
    let bowtie = 
      let returns_equal ret m1_tag m2_tag = 
        List.mapi (fun i _ -> Smt.EBop(Smt.Eq, 
                                          EVar(Var (sp "result_%d_%s" i m1_tag)),
                                          EVar(Var (sp "result_%d_%s" i m2_tag)))
                 ) ret
      in
      let states_equal state m1m2_tag m2m1_tag =
        let s_m1m2 = state in
        let s_m2m1 = make_new_bindings state in
        let state_eq_args = s_m1m2 @ s_m2m1 in
        let state_eq_c_args = 
          List.map (compose (Fun.flip String.cat m1m2_tag) name_of_c_arg) s_m1m2
          @ List.map (compose (Fun.flip String.cat m2m1_tag) name_of_c_arg) s_m2m1
        in
        apply_method state_eq_args state_eq_c_args spec.state_eq
      in
      (returns_equal m1.ret "1" "21") 
      @ (returns_equal m2.ret "2" "12")
      @ [states_equal spec.state "12" "21"]
    in  

    pfvv "DEBUG: \n ==== \n__Oper__:=>\n%s\n ===\nDEBUG END\n" (
        String.concat "\n" 
          (List.mapi (fun i c -> 
               sp "%s: %s" 
                 (if ((i mod 2) == 0) then "Maybe PRE" else "Maybe POST") 
                 (string_of_smt c)) 
              oper));
    pfvv "DEBUG: \n ==== \n__Bowtie__:=>\n%s\n ===\nDEBUG END\n" (
        String.concat "\n" 
          (List.mapi (fun i c -> 
               sp "Clause: %s"  
                 (string_of_smt c)) 
              bowtie));

    (* 4. Glue all together and generate smt query for ABC MC *)
    let oper_assert = sp "(assert %s)" @@ Smt.string_of_smt (Smt.ELop(Smt.And, oper)) in
    let bowtie_assert = sp "(assert %s)" @@ Smt.string_of_smt (Smt.ELop(Smt.And, bowtie)) in
    let commute_cond_assert = sp "(assert %s)" @@ Smt.string_of_smt @@ (
        match h_pred with
          | HPredConj conj -> smt_of_conj conj
          | HPredDisj d -> smt_of_disj d) in
    (spec_preable, !vars_ref, oper_assert, bowtie_assert,  commute_cond_assert)

  
  let create_smt_file smt fname = 
    let oc = open_out fname in
    Printf.fprintf oc "%s" smt;
    close_out oc

  let remove_smt_file fname = 
    Sys.remove fname

  let count h_label (preamble_str, vars_str, oper_str, bowtie_str, commute_cond_str) = 
    let module MC = ABCModelCounter in
    let string_of_mc_query = unlines ~trailing_newline: true [
        "(set-logic ALL)";
        preamble_str;
        vars_str;
        (* oper_str; "";
         * bowtie_str; ""; *)
        commute_cond_str; "";
        "(check-sat)"] 
    in 
    pfv "<<< MC SMT QUERY [%s] >>>:\n%s\n<<< MC END >>>\n" h_label string_of_mc_query;
   
    create_smt_file string_of_mc_query MC.smt_fname;
    let result = run_model_counter (module MC) |> MC.parse_output in
    pfv "\nModel counting for %s: \n|?| %s \n|-> Result: %s\n--------------------------\n"
      h_label 
      (Str.global_replace (Str.regexp "\n") "\n|?| " string_of_mc_query) 
      (begin match result with
         | Sat c -> sp "Sat; bound %d; count: %d" MC.bound_int  c
         | Unsat -> "Unsat"
         | Unknown -> "Unknown"
       end);
    remove_smt_file MC.smt_fname;
    result

  let count_pred pred_label (vars_str, pred_str) = 
    let module MC = ABCModelCounter in
    let string_of_mc_query = unlines ~trailing_newline: true [
        "(set-logic ALL)";
        vars_str; "";
        sp "(assert %s)" pred_str;
        "(check-sat)"] 
    in 
    pfv "<<< MC SMT QUERY [%s] >>>:\n%s\n<<< MC END >>>\n" pred_label string_of_mc_query;
   
    create_smt_file string_of_mc_query MC.smt_fname;
    let result = run_model_counter (module MC) |> MC.parse_output in
    pfv "\nModel counting for %s: \n|?| %s \n|-> Result: %s\n--------------------------\n"
      pred_label 
      (Str.global_replace (Str.regexp "\n") "\n|?| " string_of_mc_query) 
      (begin match result with
         | Sat c -> sp "Sat; bound %d; count: %d" MC.bound_int  c
         | Unsat -> "Unsat"
         | Unknown -> "Unknown"
       end);
    remove_smt_file MC.smt_fname;
    result
end

let count h spec conj = CommuteConditionsCount.smt_query_str spec conj 
                        |> CommuteConditionsCount.count h

let count_pred lbl smt_parts = CommuteConditionsCount.count_pred lbl smt_parts
 
